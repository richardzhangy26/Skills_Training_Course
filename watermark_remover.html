<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å›¾ç‰‡æ°´å°å»é™¤å·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2em;
        }
        
        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 30px;
        }
        
        .upload-area:hover {
            background: #f0f4ff;
            border-color: #764ba2;
        }
        
        .upload-area.dragover {
            background: #e0e8ff;
            border-color: #764ba2;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .upload-icon {
            font-size: 50px;
            margin-bottom: 15px;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 20px;
        }
        
        button {
            padding: 12px 30px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: #f0f0f0;
            color: #333;
        }
        
        .btn-secondary:hover:not(:disabled) {
            background: #e0e0e0;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .canvas-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        
        .canvas-wrapper {
            text-align: center;
        }
        
        .canvas-wrapper h3 {
            margin-bottom: 10px;
            color: #555;
        }
        
        canvas {
            border: 2px solid #ddd;
            border-radius: 10px;
            max-width: 100%;
            cursor: crosshair;
        }
        
        .info {
            background: #f0f4ff;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            color: #555;
        }
        
        .slider-group {
            margin: 15px 0;
            text-align: center;
        }
        
        .slider-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }
        
        input[type="range"] {
            width: 100%;
            max-width: 300px;
        }
        
        .value-display {
            display: inline-block;
            margin-left: 10px;
            color: #667eea;
            font-weight: bold;
        }

        .processing {
            text-align: center;
            color: #667eea;
            font-weight: bold;
            margin: 20px 0;
        }

        .error {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¨ å›¾ç‰‡æ°´å°å»é™¤å·¥å…·</h1>
        
        <div class="error" id="errorMsg"></div>
        
        <div class="info">
            <strong>ä½¿ç”¨è¯´æ˜ï¼š</strong>
            <ol style="margin-left: 20px; margin-top: 10px;">
                <li>ä¸Šä¼ æˆ–æ‹–æ‹½å›¾ç‰‡åˆ°ä¸Šä¼ åŒºåŸŸ</li>
                <li>åœ¨å·¦ä¾§åŸå›¾ä¸Šç”¨é¼ æ ‡æ¶‚æŠ¹æ ‡è®°æ°´å°åŒºåŸŸï¼ˆæŒ‰ä½é¼ æ ‡å·¦é”®æ‹–åŠ¨ï¼‰</li>
                <li>è°ƒæ•´ç”»ç¬”å¤§å°å’Œä¿®å¤å¼ºåº¦</li>
                <li>ç‚¹å‡»"å»é™¤æ°´å°"æŸ¥çœ‹æ•ˆæœ</li>
                <li>æ»¡æ„åå¯ä¸‹è½½å¤„ç†åçš„å›¾ç‰‡</li>
            </ol>
        </div>
        
        <div class="upload-area" id="uploadArea">
            <div class="upload-icon">ğŸ“</div>
            <h2>ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ å›¾ç‰‡</h2>
            <p style="color: #888; margin-top: 10px;">æ”¯æŒ JPG, PNG, GIF æ ¼å¼</p>
            <input type="file" id="fileInput" accept="image/*">
        </div>
        
        <div class="slider-group">
            <label>
                ç”»ç¬”å¤§å°: <span class="value-display" id="brushSizeValue">20</span>px
            </label>
            <input type="range" id="brushSize" min="5" max="100" value="20">
        </div>

        <div class="slider-group">
            <label>
                ä¿®å¤å¼ºåº¦: <span class="value-display" id="iterationsValue">30</span> æ¬¡è¿­ä»£
            </label>
            <input type="range" id="iterations" min="10" max="100" value="30">
        </div>

        <div class="slider-group">
            <label>
                ä¿®å¤ç®—æ³•: 
                <select id="algorithmSelect" style="padding: 5px; border-radius: 5px; border: 1px solid #ddd; font-size: 14px;">
                    <option value="advanced">é«˜çº§ä¿®å¤ï¼ˆæ¨èï¼‰</option>
                    <option value="basic">åŸºç¡€ä¿®å¤</option>
                    <option value="texture">çº¹ç†ä¿æŒ</option>
                </select>
            </label>
        </div>
        
        <div class="controls">
            <button class="btn-primary" id="processBtn" disabled>ğŸš€ å»é™¤æ°´å°</button>
            <button class="btn-secondary" id="clearBtn" disabled>ğŸ”„ æ¸…é™¤æ ‡è®°</button>
            <button class="btn-secondary" id="downloadBtn" disabled>ğŸ’¾ ä¸‹è½½å›¾ç‰‡</button>
        </div>

        <div class="processing" id="processingMsg" style="display: none;"></div>
        
        <div class="canvas-container">
            <div class="canvas-wrapper">
                <h3>åŸå›¾ï¼ˆæ ‡è®°æ°´å°åŒºåŸŸï¼‰</h3>
                <canvas id="originalCanvas"></canvas>
            </div>
            <div class="canvas-wrapper">
                <h3>å¤„ç†å</h3>
                <canvas id="resultCanvas"></canvas>
            </div>
        </div>
    </div>

    <script>
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const originalCanvas = document.getElementById('originalCanvas');
        const resultCanvas = document.getElementById('resultCanvas');
        const processBtn = document.getElementById('processBtn');
        const clearBtn = document.getElementById('clearBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const brushSize = document.getElementById('brushSize');
        const brushSizeValue = document.getElementById('brushSizeValue');
        const iterations = document.getElementById('iterations');
        const iterationsValue = document.getElementById('iterationsValue');
        const processingMsg = document.getElementById('processingMsg');
        const errorMsg = document.getElementById('errorMsg');
        
        let octx, rctx;
        let img = null;
        let isDrawing = false;
        let mask = null;
        let originalImageData = null;
        let displayScale = 1; // æ˜¾ç¤ºç¼©æ”¾æ¯”ä¾‹
        let fullResCanvas = null; // å…¨åˆ†è¾¨ç‡canvas
        let originalFileName = 'image'; // ä¿å­˜åŸå§‹æ–‡ä»¶å
        
        // åˆå§‹åŒ–canvasä¸Šä¸‹æ–‡
        try {
            octx = originalCanvas.getContext('2d', { willReadFrequently: true });
            rctx = resultCanvas.getContext('2d', { willReadFrequently: true });
        } catch (e) {
            showError('Canvasåˆå§‹åŒ–å¤±è´¥: ' + e.message);
        }
        
        function showError(msg) {
            errorMsg.textContent = 'é”™è¯¯: ' + msg;
            errorMsg.style.display = 'block';
            console.error(msg);
        }

        function hideError() {
            errorMsg.style.display = 'none';
        }
        
        // ä¸Šä¼ åŒºåŸŸäº‹ä»¶
        uploadArea.addEventListener('click', () => fileInput.click());
        
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                loadImage(file);
            }
        });
        
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) loadImage(file);
        });
        
        // æ»‘å—äº‹ä»¶
        brushSize.addEventListener('input', (e) => {
            brushSizeValue.textContent = e.target.value;
        });

        iterations.addEventListener('input', (e) => {
            iterationsValue.textContent = e.target.value;
        });
        
        // åŠ è½½å›¾ç‰‡
        function loadImage(file) {
            hideError();

            // ä¿å­˜åŸå§‹æ–‡ä»¶åï¼ˆå»æ‰æ‰©å±•åï¼‰
            originalFileName = file.name.replace(/\.[^/.]+$/, '');

            const reader = new FileReader();

            reader.onerror = () => {
                showError('æ–‡ä»¶è¯»å–å¤±è´¥');
            };

            reader.onload = (e) => {
                img = new Image();
                
                img.onerror = () => {
                    showError('å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œè¯·ç¡®ä¿æ–‡ä»¶æ˜¯æœ‰æ•ˆçš„å›¾ç‰‡æ ¼å¼');
                };
                
                img.onload = () => {
                    try {
                        // åŸå§‹å°ºå¯¸
                        const fullWidth = img.width;
                        const fullHeight = img.height;
                        
                        // æ˜¾ç¤ºå°ºå¯¸ï¼ˆç¼©å°ç”¨äºç•Œé¢æ˜¾ç¤ºï¼‰
                        const maxWidth = 500;
                        displayScale = img.width > maxWidth ? maxWidth / img.width : 1;
                        const displayWidth = Math.floor(img.width * displayScale);
                        const displayHeight = Math.floor(img.height * displayScale);
                        
                        // è®¾ç½®æ˜¾ç¤ºcanvaså¤§å°
                        originalCanvas.width = displayWidth;
                        originalCanvas.height = displayHeight;
                        resultCanvas.width = displayWidth;
                        resultCanvas.height = displayHeight;
                        
                        // ç»˜åˆ¶ç¼©å°çš„å›¾åƒç”¨äºæ˜¾ç¤º
                        octx.drawImage(img, 0, 0, displayWidth, displayHeight);
                        rctx.clearRect(0, 0, displayWidth, displayHeight);
                        
                        // ä¿å­˜åŸå§‹å›¾åƒæ•°æ®ï¼ˆæ˜¾ç¤ºç”¨ï¼‰
                        originalImageData = octx.getImageData(0, 0, displayWidth, displayHeight);
                        
                        // åˆ›å»ºå…¨åˆ†è¾¨ç‡canvasï¼ˆç”¨äºæœ€ç»ˆå¤„ç†ï¼‰
                        fullResCanvas = document.createElement('canvas');
                        fullResCanvas.width = fullWidth;
                        fullResCanvas.height = fullHeight;
                        const fullCtx = fullResCanvas.getContext('2d', { willReadFrequently: true });
                        fullCtx.drawImage(img, 0, 0);
                        
                        // åˆå§‹åŒ–maskï¼ˆä½¿ç”¨æ˜¾ç¤ºå°ºå¯¸ï¼‰
                        mask = [];
                        for (let y = 0; y < displayHeight; y++) {
                            mask[y] = [];
                            for (let x = 0; x < displayWidth; x++) {
                                mask[y][x] = false;
                            }
                        }
                        
                        processBtn.disabled = false;
                        clearBtn.disabled = false;
                        downloadBtn.disabled = true;
                        
                        console.log(`å›¾ç‰‡åŠ è½½æˆåŠŸ - åŸå§‹: ${fullWidth}x${fullHeight}, æ˜¾ç¤º: ${displayWidth}x${displayHeight}`);
                    } catch (e) {
                        showError('å›¾ç‰‡å¤„ç†å¤±è´¥: ' + e.message);
                    }
                };
                
                img.src = e.target.result;
            };
            
            reader.readAsDataURL(file);
        }
        
        // ç»˜åˆ¶æ ‡è®°
        originalCanvas.addEventListener('mousedown', startDrawing);
        originalCanvas.addEventListener('mousemove', draw);
        originalCanvas.addEventListener('mouseup', stopDrawing);
        originalCanvas.addEventListener('mouseleave', stopDrawing);
        
        // è§¦æ‘¸æ”¯æŒ
        originalCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            originalCanvas.dispatchEvent(mouseEvent);
        });
        
        originalCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            originalCanvas.dispatchEvent(mouseEvent);
        });
        
        originalCanvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            stopDrawing();
        });
        
        function startDrawing(e) {
            isDrawing = true;
            drawMask(e);
        }
        
        function draw(e) {
            if (isDrawing) {
                drawMask(e);
            }
        }
        
        function stopDrawing() {
            isDrawing = false;
        }
        
        function drawMask(e) {
            if (!mask) return;
            
            const rect = originalCanvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) * (originalCanvas.width / rect.width));
            const y = Math.floor((e.clientY - rect.top) * (originalCanvas.height / rect.height));
            const size = parseInt(brushSize.value);
            const radius = Math.floor(size / 2);
            
            // ç»˜åˆ¶çº¢è‰²åŠé€æ˜æ ‡è®°
            octx.globalAlpha = 0.5;
            octx.fillStyle = '#ff0000';
            octx.beginPath();
            octx.arc(x, y, radius, 0, Math.PI * 2);
            octx.fill();
            octx.globalAlpha = 1;
            
            // æ›´æ–°maskæ•°ç»„
            const width = originalCanvas.width;
            const height = originalCanvas.height;
            
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    if (dx * dx + dy * dy <= radius * radius) {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            mask[ny][nx] = true;
                        }
                    }
                }
            }
        }
        
        // æ¸…é™¤æ ‡è®°
        clearBtn.addEventListener('click', () => {
            if (!originalImageData) return;
            
            octx.putImageData(originalImageData, 0, 0);
            const width = originalCanvas.width;
            const height = originalCanvas.height;
            
            mask = [];
            for (let y = 0; y < height; y++) {
                mask[y] = [];
                for (let x = 0; x < width; x++) {
                    mask[y][x] = false;
                }
            }
            
            rctx.clearRect(0, 0, resultCanvas.width, resultCanvas.height);
            downloadBtn.disabled = true;
            processingMsg.style.display = 'none';
        });
        
        // å¤„ç†æ°´å°
        processBtn.addEventListener('click', async () => {
            if (!originalImageData || !mask || !fullResCanvas) {
                showError('è¯·å…ˆä¸Šä¼ å›¾ç‰‡å¹¶æ ‡è®°æ°´å°åŒºåŸŸ');
                return;
            }
            
            hideError();
            processingMsg.style.display = 'block';
            processingMsg.textContent = 'æ­£åœ¨å¤„ç†åŸå§‹åˆ†è¾¨ç‡å›¾ç‰‡ï¼Œè¯·ç¨å€™...';
            processBtn.disabled = true;
            
            await new Promise(resolve => setTimeout(resolve, 100));
            
            try {
                const displayWidth = originalCanvas.width;
                const displayHeight = originalCanvas.height;
                const fullWidth = fullResCanvas.width;
                const fullHeight = fullResCanvas.height;
                
                // å°†maskç¼©æ”¾åˆ°å…¨åˆ†è¾¨ç‡ï¼ˆä½¿ç”¨æ›´å¥½çš„ç¼©æ”¾ç®—æ³•ï¼‰
                const fullResMask = [];
                const scaleX = fullWidth / displayWidth;
                const scaleY = fullHeight / displayHeight;
                
                for (let y = 0; y < fullHeight; y++) {
                    fullResMask[y] = [];
                    for (let x = 0; x < fullWidth; x++) {
                        const srcX = Math.floor(x / scaleX);
                        const srcY = Math.floor(y / scaleY);
                        // ç¡®ä¿ç´¢å¼•åœ¨èŒƒå›´å†…
                        const safeX = Math.min(srcX, displayWidth - 1);
                        const safeY = Math.min(srcY, displayHeight - 1);
                        fullResMask[y][x] = mask[safeY][safeX];
                    }
                }
                
                // è·å–å…¨åˆ†è¾¨ç‡å›¾åƒæ•°æ®
                const fullCtx = fullResCanvas.getContext('2d', { willReadFrequently: true });
                const fullImageData = fullCtx.getImageData(0, 0, fullWidth, fullHeight);
                const data = fullImageData.data;
                
                const numIterations = parseInt(iterations.value);
                
                // åœ¨å…¨åˆ†è¾¨ç‡ä¸Šè¿­ä»£ä¿®å¤ï¼ˆä½¿ç”¨æ›´å¤§çš„é‡‡æ ·èŒƒå›´ï¼‰
                for (let iter = 0; iter < numIterations; iter++) {
                    processingMsg.textContent = `æ­£åœ¨å¤„ç†: ${Math.floor((iter + 1) / numIterations * 100)}%`;
                    
                    for (let y = 2; y < fullHeight - 2; y++) {
                        for (let x = 2; x < fullWidth - 2; x++) {
                            if (fullResMask[y][x]) {
                                let r = 0, g = 0, b = 0;
                                let totalWeight = 0;
                                
                                // é‡‡æ ·å‘¨å›´åƒç´ ï¼ˆæ ¹æ®å›¾ç‰‡å¤§å°è°ƒæ•´èŒƒå›´ï¼‰
                                const sampleRadius = Math.max(2, Math.floor(Math.min(fullWidth, fullHeight) / 200));
                                
                                for (let dy = -sampleRadius; dy <= sampleRadius; dy++) {
                                    for (let dx = -sampleRadius; dx <= sampleRadius; dx++) {
                                        if (dx === 0 && dy === 0) continue;
                                        
                                        const nx = x + dx;
                                        const ny = y + dy;
                                        
                                        if (nx >= 0 && nx < fullWidth && ny >= 0 && ny < fullHeight) {
                                            if (!fullResMask[ny][nx] || iter > 0) {
                                                const idx = (ny * fullWidth + nx) * 4;
                                                const dist = Math.sqrt(dx * dx + dy * dy);
                                                const weight = 1 / (dist * dist);
                                                
                                                r += data[idx] * weight;
                                                g += data[idx + 1] * weight;
                                                b += data[idx + 2] * weight;
                                                totalWeight += weight;
                                            }
                                        }
                                    }
                                }
                                
                                if (totalWeight > 0) {
                                    const idx = (y * fullWidth + x) * 4;
                                    data[idx] = Math.round(r / totalWeight);
                                    data[idx + 1] = Math.round(g / totalWeight);
                                    data[idx + 2] = Math.round(b / totalWeight);
                                }
                            }
                        }
                    }
                    
                    if (iter % 5 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 1));
                    }
                }
                
                // æ›´æ–°å…¨åˆ†è¾¨ç‡canvas
                fullCtx.putImageData(fullImageData, 0, 0);
                
                // åœ¨ç»“æœcanvasæ˜¾ç¤ºç¼©å°ç‰ˆæœ¬
                rctx.drawImage(fullResCanvas, 0, 0, displayWidth, displayHeight);
                
                downloadBtn.disabled = false;
                processBtn.disabled = false;
                processingMsg.textContent = `å¤„ç†å®Œæˆï¼åŸå§‹åˆ†è¾¨ç‡: ${fullWidth}x${fullHeight}`;
                setTimeout(() => {
                    processingMsg.style.display = 'none';
                }, 3000);
            } catch (e) {
                showError('å¤„ç†å¤±è´¥: ' + e.message);
                processBtn.disabled = false;
                processingMsg.style.display = 'none';
            }
        });
        
        // ä¸‹è½½å›¾ç‰‡
        downloadBtn.addEventListener('click', async () => {
            try {
                if (!fullResCanvas) {
                    showError('æ²¡æœ‰å¯ä¸‹è½½çš„å›¾ç‰‡');
                    return;
                }
                
                processingMsg.style.display = 'block';
                processingMsg.textContent = 'æ­£åœ¨å‡†å¤‡ä¸‹è½½...';
                
                // ä½¿ç”¨æ›´å¥½çš„å‹ç¼©è´¨é‡ï¼Œå¦‚æœå›¾ç‰‡å¤ªå¤§åˆ™åˆ†æ­¥å¤„ç†
                await new Promise(resolve => setTimeout(resolve, 100));
                
                fullResCanvas.toBlob((blob) => {
                    if (!blob) {
                        showError('å›¾ç‰‡ç”Ÿæˆå¤±è´¥ï¼Œå¯èƒ½å›¾ç‰‡è¿‡å¤§');
                        processingMsg.style.display = 'none';
                        return;
                    }
                    
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.download = `${originalFileName}-watermark-removed.png`;
                    link.href = url;
                    link.click();
                    
                    // æ¸…ç†URLå¯¹è±¡
                    setTimeout(() => URL.revokeObjectURL(url), 100);
                    
                    processingMsg.textContent = `ä¸‹è½½æˆåŠŸï¼åˆ†è¾¨ç‡: ${fullResCanvas.width}x${fullResCanvas.height}`;
                    setTimeout(() => {
                        processingMsg.style.display = 'none';
                    }, 2000);
                    
                    console.log(`å·²ä¸‹è½½å›¾ç‰‡ï¼Œåˆ†è¾¨ç‡: ${fullResCanvas.width}x${fullResCanvas.height}`);
                }, 'image/png', 1.0);
                
            } catch (e) {
                showError('ä¸‹è½½å¤±è´¥: ' + e.message);
                processingMsg.style.display = 'none';
            }
        });
    </script>
</body>
</html>